---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# vg250

<!-- badges: start -->
<!-- badges: end -->

vg250 is a helper package to provide access to VG250 dataset in order to derive 
spatial information for a chosen administrative level for various applications.

Since I found myself in the need of some kind of spatial information on a 
municipality level for convenience reasons quite often, the decision was made to 
centralize associated data and functions based on `{sf}` in a separate package 
to simplify maintenance.

## Installation

You can install the development version of vg250 from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("dimfalk/vg250")
```

## Basic examples

Just a few quick insights on the use of this package:

```{r example}
library(vg250)

# fetch data
geom <- get_geometry("Aachen")
e <- get_extent("Aachen")
p <- get_centroid("Aachen")

# check classes
class(geom)
class(e)
class(p)

# inspect visually
library(ggplot2)

ggplot() + 
  geom_sf(data = e) + 
  geom_sf(data = geom, col = "red") + 
  geom_sf(data = p, col = "blue")
```

This information can now be used to e.g. create masks to crop raster data, 
select vector features, perform spatial joins, construct API calls, etc.

```{r warning = FALSE}
# convert to SpatExtent object when working with `{terra}`
terra::vect(e) |> terra::ext()

# select vector features by p
sf::st_filter(vg250, p)

# join attributes spatially to p
sf::st_intersection(vg250, p)

# construct API queries
sf::st_bbox(e) |> as.numeric() |> round(4) |> paste0(collapse = ",") |> paste0("&bbox=", x = _)
```
Note: The VG250 dataset itself can be accessed via `vg250`:

```{r warning = FALSE}
vg250
```
